> 우리가 흔히 말하는 리액트의 특징 중 하나인 가상 DOM, Virtual DOM 에 대한 이야기

# DOM 과 브라우저의 렌더링 과정

## DOM 이란 ?

Document Object Model 의 약자로, 웹페에지에 대한 인터페이스이며 브라우저가 웹페이지의 콘텐츠를 어떻게 보여줄지에 대한 정보를 담고 있음

## 렌더링 과정

1. HTML 파일을 다운로드
2. 브라우저의 렌더링 엔진이 HTML을 파싱하여 DOM 노드로 구성된 DOM 트리 생성
3. 만약 CSS 파일을 만나게 된다면 CSS 파일도 다운로드
4. 해당 CSS도 파싱하여 CSS 노드로 구성된 CSSOM 트리 생성
5. 브라우저가 2번 DOM 노드를 순회
   1. 이때 display: none 과 같이 눈에 안 보이는 요소는 순회하지 않는다
6. 눈에 보이는 요소에 대하여 노드에 대한 CSSOM을 찾고, CSS 스타일 정보를 해당 노드에 적용

---

이때 노드에 CSS에 적용하는 과정은 2가지로 나뉨

레이아웃 : 노드를 브라우저 상에 위치시킴. 레이아웃이 발생하면 페인팅도 뒤따라 발생

페인팅: 레이아웃 단계를 걸친 노드에 색상을 입히는 것과 같이 유효한 모습을 그림

# 가상 DOM 의 탄생 배경

- 여러 애플리케이션들이 사용자의 인터랙션에 따라 요소들을 변경함
  - 이때 요소의 위치나 간격 등을 수정할 경우 레이아웃이 발생하고, 이에 따라 리페인팅이 발생하여 많은 처리 비용이 발생
- SPA(Single Page Application) 에서는 하나의 페이지에서 계속해서 요소의 위치를 계산
  - 라우팅이 변경되면 대다수의 요소를 새롭게 배치
  - DOM 관리 비용에 있어 부담 발생
- 이러한 상황에서 DOM 의 모든 변경 사항을 추적하기보다 최종적으로 완성되는 DOM을 확인하고자 함

⇒ 가상 DOM이 탄생

### 가상 DOM

실제 브라우저의 DOM이 아닌 리액트에서 관리하는 가상의 DOM

- 웹페이지에 표시해야할 DOM 을 우선 메모리에 저장 후 변경할 준비가 완료되면 실제 브라우저의 DOM 에 반영
  - 브라우저가 아닌 메모리에서 계산하는 과정을 거쳐 렌더링 과정 최소화 및 개발자의 부담을 덜 수 있음

# 가상 DOM 을 위한 리액트 파이버

> 가상 DOM 의 렌더링과 최적화를 도와주는 리액트의 자바스크립트 객체

### 재조정자 fiver conciler

- 파이버를 관리
- 가상 DOM 과 실제 DOM을 비교하여 변경사항 수집
- 차이가 있다면 변경된 정보를 가진 파이버를 기준으로 화면에 렌더링 요청
- 가상 DOM 과 실제 DOM을 비교하는 작업 수행

파이버에서 발생하는 작업들 ex) 작업을 작은 단위로 쪼개고 우선 순위 부여, 작업을 중지하고 나중에 다시 시작 등.. 은 모두 비동기로 발생

- 초기에는 스택 알고리즘으로 동기적으로 발생
- 스택에 작업들이 쌓이면 작업에 많은 시간 소요 및 이벤트 지연 발생 가능

→ 파이버라는 개념 도입

### 파이버의 동작

- 파이버는 하나의 작업 단위로 구성
- 리액트는 해당 단위를 처리 후 finishedWork() 로 작업 마무리
- 이 작업을 커밋하여 실제 DOM 에 변경 사항 만들어 냄

다음과 같이 2 단계롤 정리하면

1. 렌더 단계에서는 사용자에게 노출되지 않는 비동기 작업 진행
2. 커밋 단계에서는 변경 사항 반영을 위해 commitWork() 실행. 동기적이며 중단 불가

- 파이버는 컴포넌트가 최초로 마운트 되는 시점에 생성된 후 가급적이면 재사용됨
- 파이버는 state가 변경, 생명주기 메서드가 실행, DOM 변경이 필요한 시점 등에서 실행
- 리액트는 이런 파이버를 처리할 때 바로 처리하거나 스케줄링을 하는 등 유연하게 처리

### 파이버 트리

리액트 내부에 2개 존재

- 현재 모습을 담은 파이버 트리
- 작업 중인 상태를 나타내는 workInProgress 트리

버퍼링: 파이버의 작업이 끝나면 포인터만 변경해 workInProgress 트리를 현재 트리로 변경

→ 불완전한 트리를 노출시키지 않기 위해 사용

- current 트리에서 업데이트 발생하면 새로 받은 데이터로 새로운 workInProgress 트리를 빌드
- workInProgress 트리의 빌드가 끝나면 다음 렌더링에 해당 트리 사용
- UI에 최종적으로 렌더링 되면 workInProgress 트리가 current 트리가 됨

### 파이버 작업 순서

1. beginWork() 함수를 수행하며 자식이 없는 파이버를 만날 때까지 트리 형식으로 진행
2. 1번이 끝나면 completeWork()를 수행하여 파이버 작업 완료
3. 형제가 있다면 형제로 넘어감
4. 2, 3번이 모두 끝나면 return 으로 돌아가 자신의 작업 완료 알림

만약 파이버 트리 생성 이후 state 값이 변경되는 등의 업데이트가 발생한다면?

→ workInProgress 트리를 빌드하는 방식은 동일하지만 파이버가 이미 존재하는 상태

따라서 파이버를 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 내부에서 처리

애플리케이션에서는 노드의 변경이 빈번히 발생하는, 변경이 일어날 때마다 새롭게 파이버를 만드는 것은 리소스의 낭비라 할 수 있음
⇒ 기존 객체 재활용

# 파이버와 가상 DOM

- 파이버는 리액트 컴포넌트에 대한 정보를 1 : 1 로 가지고 있음
- 리액트 아키텍처 내부에서 비동기로 발생
- 실제 브라우저 DOM 에 반영하는 것은 동기적으로 발생해야함
- 화면에 불완전하게 표시되는 것을 막기 위해 가상 (메모리)에서 먼저 변경 작업 수행 후, 최종 결과물만 실제 브라우저 DOM 에 적용

# 정리

- 현대 애플리케이션은 사용자 인터랙션으로 인하여 노드 및 DOM 의 수정이 빈번하게 발생
- DOM 관리 비용 측면에서 최종적인 결과물의 DOM 확인을 위하여 가상 DOM 을 도입
- 가상 DOM 은 가상 (메모리)에서 먼저 변경 사항들을 반영하여 DOM 을 계산 후 실제 DOM 에 반영
- 이 변경 사항을 계산하는 과정은 파이버를 통해서 진행
- 파이버는 가상 DOM 과 실제 DOM 을 비교하는 작업을 수행하는 자바스크립트 객체
- 현재 파이버 트리에서 변경점을 workInProgress 트리에 반영한 후, 빌드가 끝나면 최종적으로 렌더링을 진행한 후 현재 트리를 workInProgress 트리로 변경
- 노드 → 형제 노드 → 자식 노드를 트리 형식으로 순회하며 파이버 작업 진행
- 한번 생성된 파이버(트리)는 재사용됨
